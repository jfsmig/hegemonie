// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminClient interface {
	//
	CreateRegion(ctx context.Context, in *RegionCreateReq, opts ...grpc.CallOption) (*None, error)
	ListRegions(ctx context.Context, in *RegionListReq, opts ...grpc.CallOption) (Admin_ListRegionsClient, error)
	// Have all the Cities on the Region to produce their resources
	Produce(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error)
	// Make all the armies on the Region to move on step
	Move(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error)
	// Compute the scoreboard of the region.
	GetScores(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (Admin_GetScoresClient, error)
	// PushStats extracts the usage in-game stats of each city in the given
	// region and pushes them to the collector.
	PushStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error)
	GetStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (Admin_GetStatsClient, error)
}

type adminClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminClient(cc grpc.ClientConnInterface) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) CreateRegion(ctx context.Context, in *RegionCreateReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Admin/CreateRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ListRegions(ctx context.Context, in *RegionListReq, opts ...grpc.CallOption) (Admin_ListRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Admin_ServiceDesc.Streams[0], "/hege.reg.Admin/ListRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminListRegionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Admin_ListRegionsClient interface {
	Recv() (*RegionSummary, error)
	grpc.ClientStream
}

type adminListRegionsClient struct {
	grpc.ClientStream
}

func (x *adminListRegionsClient) Recv() (*RegionSummary, error) {
	m := new(RegionSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *adminClient) Produce(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Admin/Produce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Move(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Admin/Move", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetScores(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (Admin_GetScoresClient, error) {
	stream, err := c.cc.NewStream(ctx, &Admin_ServiceDesc.Streams[1], "/hege.reg.Admin/GetScores", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminGetScoresClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Admin_GetScoresClient interface {
	Recv() (*PublicCity, error)
	grpc.ClientStream
}

type adminGetScoresClient struct {
	grpc.ClientStream
}

func (x *adminGetScoresClient) Recv() (*PublicCity, error) {
	m := new(PublicCity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *adminClient) PushStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Admin/PushStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (Admin_GetStatsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Admin_ServiceDesc.Streams[2], "/hege.reg.Admin/GetStats", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminGetStatsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Admin_GetStatsClient interface {
	Recv() (*CityStats, error)
	grpc.ClientStream
}

type adminGetStatsClient struct {
	grpc.ClientStream
}

func (x *adminGetStatsClient) Recv() (*CityStats, error) {
	m := new(CityStats)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AdminServer is the server API for Admin service.
// All implementations must embed UnimplementedAdminServer
// for forward compatibility
type AdminServer interface {
	//
	CreateRegion(context.Context, *RegionCreateReq) (*None, error)
	ListRegions(*RegionListReq, Admin_ListRegionsServer) error
	// Have all the Cities on the Region to produce their resources
	Produce(context.Context, *RegionId) (*None, error)
	// Make all the armies on the Region to move on step
	Move(context.Context, *RegionId) (*None, error)
	// Compute the scoreboard of the region.
	GetScores(*RegionId, Admin_GetScoresServer) error
	// PushStats extracts the usage in-game stats of each city in the given
	// region and pushes them to the collector.
	PushStats(context.Context, *RegionId) (*None, error)
	GetStats(*RegionId, Admin_GetStatsServer) error
	mustEmbedUnimplementedAdminServer()
}

// UnimplementedAdminServer must be embedded to have forward compatible implementations.
type UnimplementedAdminServer struct {
}

func (UnimplementedAdminServer) CreateRegion(context.Context, *RegionCreateReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRegion not implemented")
}
func (UnimplementedAdminServer) ListRegions(*RegionListReq, Admin_ListRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListRegions not implemented")
}
func (UnimplementedAdminServer) Produce(context.Context, *RegionId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Produce not implemented")
}
func (UnimplementedAdminServer) Move(context.Context, *RegionId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedAdminServer) GetScores(*RegionId, Admin_GetScoresServer) error {
	return status.Errorf(codes.Unimplemented, "method GetScores not implemented")
}
func (UnimplementedAdminServer) PushStats(context.Context, *RegionId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushStats not implemented")
}
func (UnimplementedAdminServer) GetStats(*RegionId, Admin_GetStatsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedAdminServer) mustEmbedUnimplementedAdminServer() {}

// UnsafeAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServer will
// result in compilation errors.
type UnsafeAdminServer interface {
	mustEmbedUnimplementedAdminServer()
}

func RegisterAdminServer(s grpc.ServiceRegistrar, srv AdminServer) {
	s.RegisterService(&Admin_ServiceDesc, srv)
}

func _Admin_CreateRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).CreateRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Admin/CreateRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).CreateRegion(ctx, req.(*RegionCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ListRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegionListReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).ListRegions(m, &adminListRegionsServer{stream})
}

type Admin_ListRegionsServer interface {
	Send(*RegionSummary) error
	grpc.ServerStream
}

type adminListRegionsServer struct {
	grpc.ServerStream
}

func (x *adminListRegionsServer) Send(m *RegionSummary) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Produce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Admin/Produce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Produce(ctx, req.(*RegionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Admin/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Move(ctx, req.(*RegionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetScores_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegionId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).GetScores(m, &adminGetScoresServer{stream})
}

type Admin_GetScoresServer interface {
	Send(*PublicCity) error
	grpc.ServerStream
}

type adminGetScoresServer struct {
	grpc.ServerStream
}

func (x *adminGetScoresServer) Send(m *PublicCity) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_PushStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).PushStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Admin/PushStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).PushStats(ctx, req.(*RegionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegionId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).GetStats(m, &adminGetStatsServer{stream})
}

type Admin_GetStatsServer interface {
	Send(*CityStats) error
	grpc.ServerStream
}

type adminGetStatsServer struct {
	grpc.ServerStream
}

func (x *adminGetStatsServer) Send(m *CityStats) error {
	return x.ServerStream.SendMsg(m)
}

// Admin_ServiceDesc is the grpc.ServiceDesc for Admin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Admin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRegion",
			Handler:    _Admin_CreateRegion_Handler,
		},
		{
			MethodName: "Produce",
			Handler:    _Admin_Produce_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _Admin_Move_Handler,
		},
		{
			MethodName: "PushStats",
			Handler:    _Admin_PushStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListRegions",
			Handler:       _Admin_ListRegions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetScores",
			Handler:       _Admin_GetScores_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetStats",
			Handler:       _Admin_GetStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// CityClient is the client API for City service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CityClient interface {
	// Paginated query of the cities owned by the given character.
	// Only a summary of the cities are returned.
	List(ctx context.Context, in *CitiesByCharReq, opts ...grpc.CallOption) (City_ListClient, error)
	// Paginated query of all the cities of the region.
	// Only a summary of the cities are returned.
	AllCities(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (City_AllCitiesClient, error)
	// Returns a complete view of the City
	// TODO(jfs): the request might fail because of a too large object
	//            to be replied.
	ShowAll(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*CityView, error)
	// Start the study of a knowledge whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Study(ctx context.Context, in *StudyReq, opts ...grpc.CallOption) (*None, error)
	// Start the construction of a building whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Build(ctx context.Context, in *BuildReq, opts ...grpc.CallOption) (*None, error)
	// Start the training of a Unit whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Train(ctx context.Context, in *TrainReq, opts ...grpc.CallOption) (*None, error)
	// Create an army around a set of units.
	// The set of units must not be empty and all the units must stay in the given City.
	CreateArmy(ctx context.Context, in *CreateArmyReq, opts ...grpc.CallOption) (*None, error)
	// Create an army around a pile of resources, with a given destination.
	// The army immediately preempts the stock in the reserve of the City
	// and starts it movement. That army will have no aggressivity.
	CreateTransport(ctx context.Context, in *CreateTransportReq, opts ...grpc.CallOption) (*None, error)
	// Transfer a Unit from the given City to the given Army.
	// The City must control the Army and the Unit must be in the City.
	TransferUnit(ctx context.Context, in *TransferUnitReq, opts ...grpc.CallOption) (*None, error)
	// Transfer a pile of Resources from the given City to the given Army.
	// The City must control the Army and the Stock must hold the amount of Resources.
	TransferResources(ctx context.Context, in *TransferResourcesReq, opts ...grpc.CallOption) (*None, error)
	// Return the list of armies that can be controlled by the given City
	ListArmies(ctx context.Context, in *CityId, opts ...grpc.CallOption) (City_ListArmiesClient, error)
}

type cityClient struct {
	cc grpc.ClientConnInterface
}

func NewCityClient(cc grpc.ClientConnInterface) CityClient {
	return &cityClient{cc}
}

func (c *cityClient) List(ctx context.Context, in *CitiesByCharReq, opts ...grpc.CallOption) (City_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &City_ServiceDesc.Streams[0], "/hege.reg.City/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type City_ListClient interface {
	Recv() (*PublicCity, error)
	grpc.ClientStream
}

type cityListClient struct {
	grpc.ClientStream
}

func (x *cityListClient) Recv() (*PublicCity, error) {
	m := new(PublicCity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cityClient) AllCities(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (City_AllCitiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &City_ServiceDesc.Streams[1], "/hege.reg.City/AllCities", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityAllCitiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type City_AllCitiesClient interface {
	Recv() (*PublicCity, error)
	grpc.ClientStream
}

type cityAllCitiesClient struct {
	grpc.ClientStream
}

func (x *cityAllCitiesClient) Recv() (*PublicCity, error) {
	m := new(PublicCity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cityClient) ShowAll(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*CityView, error) {
	out := new(CityView)
	err := c.cc.Invoke(ctx, "/hege.reg.City/ShowAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) Study(ctx context.Context, in *StudyReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/Study", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) Build(ctx context.Context, in *BuildReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/Build", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) Train(ctx context.Context, in *TrainReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/Train", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) CreateArmy(ctx context.Context, in *CreateArmyReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/CreateArmy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) CreateTransport(ctx context.Context, in *CreateTransportReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/CreateTransport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) TransferUnit(ctx context.Context, in *TransferUnitReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/TransferUnit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) TransferResources(ctx context.Context, in *TransferResourcesReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/TransferResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) ListArmies(ctx context.Context, in *CityId, opts ...grpc.CallOption) (City_ListArmiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &City_ServiceDesc.Streams[2], "/hege.reg.City/ListArmies", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityListArmiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type City_ListArmiesClient interface {
	Recv() (*ArmyName, error)
	grpc.ClientStream
}

type cityListArmiesClient struct {
	grpc.ClientStream
}

func (x *cityListArmiesClient) Recv() (*ArmyName, error) {
	m := new(ArmyName)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CityServer is the server API for City service.
// All implementations must embed UnimplementedCityServer
// for forward compatibility
type CityServer interface {
	// Paginated query of the cities owned by the given character.
	// Only a summary of the cities are returned.
	List(*CitiesByCharReq, City_ListServer) error
	// Paginated query of all the cities of the region.
	// Only a summary of the cities are returned.
	AllCities(*PaginatedU64Query, City_AllCitiesServer) error
	// Returns a complete view of the City
	// TODO(jfs): the request might fail because of a too large object
	//            to be replied.
	ShowAll(context.Context, *CityId) (*CityView, error)
	// Start the study of a knowledge whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Study(context.Context, *StudyReq) (*None, error)
	// Start the construction of a building whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Build(context.Context, *BuildReq) (*None, error)
	// Start the training of a Unit whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Train(context.Context, *TrainReq) (*None, error)
	// Create an army around a set of units.
	// The set of units must not be empty and all the units must stay in the given City.
	CreateArmy(context.Context, *CreateArmyReq) (*None, error)
	// Create an army around a pile of resources, with a given destination.
	// The army immediately preempts the stock in the reserve of the City
	// and starts it movement. That army will have no aggressivity.
	CreateTransport(context.Context, *CreateTransportReq) (*None, error)
	// Transfer a Unit from the given City to the given Army.
	// The City must control the Army and the Unit must be in the City.
	TransferUnit(context.Context, *TransferUnitReq) (*None, error)
	// Transfer a pile of Resources from the given City to the given Army.
	// The City must control the Army and the Stock must hold the amount of Resources.
	TransferResources(context.Context, *TransferResourcesReq) (*None, error)
	// Return the list of armies that can be controlled by the given City
	ListArmies(*CityId, City_ListArmiesServer) error
	mustEmbedUnimplementedCityServer()
}

// UnimplementedCityServer must be embedded to have forward compatible implementations.
type UnimplementedCityServer struct {
}

func (UnimplementedCityServer) List(*CitiesByCharReq, City_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCityServer) AllCities(*PaginatedU64Query, City_AllCitiesServer) error {
	return status.Errorf(codes.Unimplemented, "method AllCities not implemented")
}
func (UnimplementedCityServer) ShowAll(context.Context, *CityId) (*CityView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowAll not implemented")
}
func (UnimplementedCityServer) Study(context.Context, *StudyReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Study not implemented")
}
func (UnimplementedCityServer) Build(context.Context, *BuildReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedCityServer) Train(context.Context, *TrainReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Train not implemented")
}
func (UnimplementedCityServer) CreateArmy(context.Context, *CreateArmyReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArmy not implemented")
}
func (UnimplementedCityServer) CreateTransport(context.Context, *CreateTransportReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTransport not implemented")
}
func (UnimplementedCityServer) TransferUnit(context.Context, *TransferUnitReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferUnit not implemented")
}
func (UnimplementedCityServer) TransferResources(context.Context, *TransferResourcesReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferResources not implemented")
}
func (UnimplementedCityServer) ListArmies(*CityId, City_ListArmiesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListArmies not implemented")
}
func (UnimplementedCityServer) mustEmbedUnimplementedCityServer() {}

// UnsafeCityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CityServer will
// result in compilation errors.
type UnsafeCityServer interface {
	mustEmbedUnimplementedCityServer()
}

func RegisterCityServer(s grpc.ServiceRegistrar, srv CityServer) {
	s.RegisterService(&City_ServiceDesc, srv)
}

func _City_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CitiesByCharReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServer).List(m, &cityListServer{stream})
}

type City_ListServer interface {
	Send(*PublicCity) error
	grpc.ServerStream
}

type cityListServer struct {
	grpc.ServerStream
}

func (x *cityListServer) Send(m *PublicCity) error {
	return x.ServerStream.SendMsg(m)
}

func _City_AllCities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedU64Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServer).AllCities(m, &cityAllCitiesServer{stream})
}

type City_AllCitiesServer interface {
	Send(*PublicCity) error
	grpc.ServerStream
}

type cityAllCitiesServer struct {
	grpc.ServerStream
}

func (x *cityAllCitiesServer) Send(m *PublicCity) error {
	return x.ServerStream.SendMsg(m)
}

func _City_ShowAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).ShowAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/ShowAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).ShowAll(ctx, req.(*CityId))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_Study_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).Study(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/Study",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).Study(ctx, req.(*StudyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/Build",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).Build(ctx, req.(*BuildReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_Train_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).Train(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/Train",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).Train(ctx, req.(*TrainReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_CreateArmy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateArmyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).CreateArmy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/CreateArmy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).CreateArmy(ctx, req.(*CreateArmyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_CreateTransport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTransportReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).CreateTransport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/CreateTransport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).CreateTransport(ctx, req.(*CreateTransportReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_TransferUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferUnitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).TransferUnit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/TransferUnit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).TransferUnit(ctx, req.(*TransferUnitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_TransferResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferResourcesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).TransferResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/TransferResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).TransferResources(ctx, req.(*TransferResourcesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_ListArmies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CityId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServer).ListArmies(m, &cityListArmiesServer{stream})
}

type City_ListArmiesServer interface {
	Send(*ArmyName) error
	grpc.ServerStream
}

type cityListArmiesServer struct {
	grpc.ServerStream
}

func (x *cityListArmiesServer) Send(m *ArmyName) error {
	return x.ServerStream.SendMsg(m)
}

// City_ServiceDesc is the grpc.ServiceDesc for City service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var City_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.City",
	HandlerType: (*CityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShowAll",
			Handler:    _City_ShowAll_Handler,
		},
		{
			MethodName: "Study",
			Handler:    _City_Study_Handler,
		},
		{
			MethodName: "Build",
			Handler:    _City_Build_Handler,
		},
		{
			MethodName: "Train",
			Handler:    _City_Train_Handler,
		},
		{
			MethodName: "CreateArmy",
			Handler:    _City_CreateArmy_Handler,
		},
		{
			MethodName: "CreateTransport",
			Handler:    _City_CreateTransport_Handler,
		},
		{
			MethodName: "TransferUnit",
			Handler:    _City_TransferUnit_Handler,
		},
		{
			MethodName: "TransferResources",
			Handler:    _City_TransferResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _City_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AllCities",
			Handler:       _City_AllCities_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListArmies",
			Handler:       _City_ListArmies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// TemplatesClient is the client API for Templates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TemplatesClient interface {
	ListTemplates(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Templates_ListTemplatesClient, error)
	CreateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*Created, error)
	UpdateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*None, error)
	DeleteTemplate(ctx context.Context, in *TemplateId, opts ...grpc.CallOption) (*None, error)
}

type templatesClient struct {
	cc grpc.ClientConnInterface
}

func NewTemplatesClient(cc grpc.ClientConnInterface) TemplatesClient {
	return &templatesClient{cc}
}

func (c *templatesClient) ListTemplates(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Templates_ListTemplatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Templates_ServiceDesc.Streams[0], "/hege.reg.Templates/ListTemplates", opts...)
	if err != nil {
		return nil, err
	}
	x := &templatesListTemplatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Templates_ListTemplatesClient interface {
	Recv() (*CityTemplate, error)
	grpc.ClientStream
}

type templatesListTemplatesClient struct {
	grpc.ClientStream
}

func (x *templatesListTemplatesClient) Recv() (*CityTemplate, error) {
	m := new(CityTemplate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *templatesClient) CreateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*Created, error) {
	out := new(Created)
	err := c.cc.Invoke(ctx, "/hege.reg.Templates/CreateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) UpdateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Templates/UpdateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) DeleteTemplate(ctx context.Context, in *TemplateId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Templates/DeleteTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TemplatesServer is the server API for Templates service.
// All implementations must embed UnimplementedTemplatesServer
// for forward compatibility
type TemplatesServer interface {
	ListTemplates(*PaginatedStrQuery, Templates_ListTemplatesServer) error
	CreateTemplate(context.Context, *CityTemplateReq) (*Created, error)
	UpdateTemplate(context.Context, *CityTemplateReq) (*None, error)
	DeleteTemplate(context.Context, *TemplateId) (*None, error)
	mustEmbedUnimplementedTemplatesServer()
}

// UnimplementedTemplatesServer must be embedded to have forward compatible implementations.
type UnimplementedTemplatesServer struct {
}

func (UnimplementedTemplatesServer) ListTemplates(*PaginatedStrQuery, Templates_ListTemplatesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTemplates not implemented")
}
func (UnimplementedTemplatesServer) CreateTemplate(context.Context, *CityTemplateReq) (*Created, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTemplate not implemented")
}
func (UnimplementedTemplatesServer) UpdateTemplate(context.Context, *CityTemplateReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTemplate not implemented")
}
func (UnimplementedTemplatesServer) DeleteTemplate(context.Context, *TemplateId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTemplate not implemented")
}
func (UnimplementedTemplatesServer) mustEmbedUnimplementedTemplatesServer() {}

// UnsafeTemplatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TemplatesServer will
// result in compilation errors.
type UnsafeTemplatesServer interface {
	mustEmbedUnimplementedTemplatesServer()
}

func RegisterTemplatesServer(s grpc.ServiceRegistrar, srv TemplatesServer) {
	s.RegisterService(&Templates_ServiceDesc, srv)
}

func _Templates_ListTemplates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedStrQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TemplatesServer).ListTemplates(m, &templatesListTemplatesServer{stream})
}

type Templates_ListTemplatesServer interface {
	Send(*CityTemplate) error
	grpc.ServerStream
}

type templatesListTemplatesServer struct {
	grpc.ServerStream
}

func (x *templatesListTemplatesServer) Send(m *CityTemplate) error {
	return x.ServerStream.SendMsg(m)
}

func _Templates_CreateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityTemplateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).CreateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Templates/CreateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).CreateTemplate(ctx, req.(*CityTemplateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_UpdateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityTemplateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).UpdateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Templates/UpdateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).UpdateTemplate(ctx, req.(*CityTemplateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_DeleteTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TemplateId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).DeleteTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Templates/DeleteTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).DeleteTemplate(ctx, req.(*TemplateId))
	}
	return interceptor(ctx, in, info, handler)
}

// Templates_ServiceDesc is the grpc.ServiceDesc for Templates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Templates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Templates",
	HandlerType: (*TemplatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTemplate",
			Handler:    _Templates_CreateTemplate_Handler,
		},
		{
			MethodName: "UpdateTemplate",
			Handler:    _Templates_UpdateTemplate_Handler,
		},
		{
			MethodName: "DeleteTemplate",
			Handler:    _Templates_DeleteTemplate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListTemplates",
			Handler:       _Templates_ListTemplates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// DefinitionsClient is the client API for Definitions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DefinitionsClient interface {
	// Return (a page of) a list of all the Units that are possible in the world
	ListUnits(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Definitions_ListUnitsClient, error)
	// Return (a page of) a list of all the Buildings that are possible in the world
	ListBuildings(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Definitions_ListBuildingsClient, error)
	// Return (a page of) a list of all the Knowledge that are possible in the world
	ListKnowledges(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Definitions_ListKnowledgesClient, error)
}

type definitionsClient struct {
	cc grpc.ClientConnInterface
}

func NewDefinitionsClient(cc grpc.ClientConnInterface) DefinitionsClient {
	return &definitionsClient{cc}
}

func (c *definitionsClient) ListUnits(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Definitions_ListUnitsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Definitions_ServiceDesc.Streams[0], "/hege.reg.Definitions/ListUnits", opts...)
	if err != nil {
		return nil, err
	}
	x := &definitionsListUnitsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Definitions_ListUnitsClient interface {
	Recv() (*UnitTypeView, error)
	grpc.ClientStream
}

type definitionsListUnitsClient struct {
	grpc.ClientStream
}

func (x *definitionsListUnitsClient) Recv() (*UnitTypeView, error) {
	m := new(UnitTypeView)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *definitionsClient) ListBuildings(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Definitions_ListBuildingsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Definitions_ServiceDesc.Streams[1], "/hege.reg.Definitions/ListBuildings", opts...)
	if err != nil {
		return nil, err
	}
	x := &definitionsListBuildingsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Definitions_ListBuildingsClient interface {
	Recv() (*BuildingTypeView, error)
	grpc.ClientStream
}

type definitionsListBuildingsClient struct {
	grpc.ClientStream
}

func (x *definitionsListBuildingsClient) Recv() (*BuildingTypeView, error) {
	m := new(BuildingTypeView)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *definitionsClient) ListKnowledges(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Definitions_ListKnowledgesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Definitions_ServiceDesc.Streams[2], "/hege.reg.Definitions/ListKnowledges", opts...)
	if err != nil {
		return nil, err
	}
	x := &definitionsListKnowledgesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Definitions_ListKnowledgesClient interface {
	Recv() (*KnowledgeTypeView, error)
	grpc.ClientStream
}

type definitionsListKnowledgesClient struct {
	grpc.ClientStream
}

func (x *definitionsListKnowledgesClient) Recv() (*KnowledgeTypeView, error) {
	m := new(KnowledgeTypeView)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DefinitionsServer is the server API for Definitions service.
// All implementations must embed UnimplementedDefinitionsServer
// for forward compatibility
type DefinitionsServer interface {
	// Return (a page of) a list of all the Units that are possible in the world
	ListUnits(*PaginatedU64Query, Definitions_ListUnitsServer) error
	// Return (a page of) a list of all the Buildings that are possible in the world
	ListBuildings(*PaginatedU64Query, Definitions_ListBuildingsServer) error
	// Return (a page of) a list of all the Knowledge that are possible in the world
	ListKnowledges(*PaginatedU64Query, Definitions_ListKnowledgesServer) error
	mustEmbedUnimplementedDefinitionsServer()
}

// UnimplementedDefinitionsServer must be embedded to have forward compatible implementations.
type UnimplementedDefinitionsServer struct {
}

func (UnimplementedDefinitionsServer) ListUnits(*PaginatedU64Query, Definitions_ListUnitsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListUnits not implemented")
}
func (UnimplementedDefinitionsServer) ListBuildings(*PaginatedU64Query, Definitions_ListBuildingsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListBuildings not implemented")
}
func (UnimplementedDefinitionsServer) ListKnowledges(*PaginatedU64Query, Definitions_ListKnowledgesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListKnowledges not implemented")
}
func (UnimplementedDefinitionsServer) mustEmbedUnimplementedDefinitionsServer() {}

// UnsafeDefinitionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DefinitionsServer will
// result in compilation errors.
type UnsafeDefinitionsServer interface {
	mustEmbedUnimplementedDefinitionsServer()
}

func RegisterDefinitionsServer(s grpc.ServiceRegistrar, srv DefinitionsServer) {
	s.RegisterService(&Definitions_ServiceDesc, srv)
}

func _Definitions_ListUnits_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedU64Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DefinitionsServer).ListUnits(m, &definitionsListUnitsServer{stream})
}

type Definitions_ListUnitsServer interface {
	Send(*UnitTypeView) error
	grpc.ServerStream
}

type definitionsListUnitsServer struct {
	grpc.ServerStream
}

func (x *definitionsListUnitsServer) Send(m *UnitTypeView) error {
	return x.ServerStream.SendMsg(m)
}

func _Definitions_ListBuildings_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedU64Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DefinitionsServer).ListBuildings(m, &definitionsListBuildingsServer{stream})
}

type Definitions_ListBuildingsServer interface {
	Send(*BuildingTypeView) error
	grpc.ServerStream
}

type definitionsListBuildingsServer struct {
	grpc.ServerStream
}

func (x *definitionsListBuildingsServer) Send(m *BuildingTypeView) error {
	return x.ServerStream.SendMsg(m)
}

func _Definitions_ListKnowledges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedU64Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DefinitionsServer).ListKnowledges(m, &definitionsListKnowledgesServer{stream})
}

type Definitions_ListKnowledgesServer interface {
	Send(*KnowledgeTypeView) error
	grpc.ServerStream
}

type definitionsListKnowledgesServer struct {
	grpc.ServerStream
}

func (x *definitionsListKnowledgesServer) Send(m *KnowledgeTypeView) error {
	return x.ServerStream.SendMsg(m)
}

// Definitions_ServiceDesc is the grpc.ServiceDesc for Definitions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Definitions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Definitions",
	HandlerType: (*DefinitionsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListUnits",
			Handler:       _Definitions_ListUnits_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListBuildings",
			Handler:       _Definitions_ListBuildings_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListKnowledges",
			Handler:       _Definitions_ListKnowledges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// ArmyClient is the client API for Army service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ArmyClient interface {
	// Return a detailed view of the given Army
	Show(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*ArmyView, error)
	// Destroy the army and return all its content to the local city
	// Only works when the city is at home.
	Cancel(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error)
	// Make the Army flea the fight it is involved in.
	Flea(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error)
	// Make the Army flip in the fight it is involved in.
	Flip(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Move(ctx context.Context, in *ArmyMoveReq, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Wait(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Attack(ctx context.Context, in *ArmyAssaultReq, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Defend(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Disband(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error)
}

type armyClient struct {
	cc grpc.ClientConnInterface
}

func NewArmyClient(cc grpc.ClientConnInterface) ArmyClient {
	return &armyClient{cc}
}

func (c *armyClient) Show(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*ArmyView, error) {
	out := new(ArmyView)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Show", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Cancel(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Flea(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Flea", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Flip(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Flip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Move(ctx context.Context, in *ArmyMoveReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Move", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Wait(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Wait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Attack(ctx context.Context, in *ArmyAssaultReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Attack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Defend(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Defend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Disband(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Disband", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArmyServer is the server API for Army service.
// All implementations must embed UnimplementedArmyServer
// for forward compatibility
type ArmyServer interface {
	// Return a detailed view of the given Army
	Show(context.Context, *ArmyId) (*ArmyView, error)
	// Destroy the army and return all its content to the local city
	// Only works when the city is at home.
	Cancel(context.Context, *ArmyId) (*None, error)
	// Make the Army flea the fight it is involved in.
	Flea(context.Context, *ArmyId) (*None, error)
	// Make the Army flip in the fight it is involved in.
	Flip(context.Context, *ArmyId) (*None, error)
	// Append the specified command on the list of the Army.
	Move(context.Context, *ArmyMoveReq) (*None, error)
	// Append the specified command on the list of the Army.
	Wait(context.Context, *ArmyTarget) (*None, error)
	// Append the specified command on the list of the Army.
	Attack(context.Context, *ArmyAssaultReq) (*None, error)
	// Append the specified command on the list of the Army.
	Defend(context.Context, *ArmyTarget) (*None, error)
	// Append the specified command on the list of the Army.
	Disband(context.Context, *ArmyTarget) (*None, error)
	mustEmbedUnimplementedArmyServer()
}

// UnimplementedArmyServer must be embedded to have forward compatible implementations.
type UnimplementedArmyServer struct {
}

func (UnimplementedArmyServer) Show(context.Context, *ArmyId) (*ArmyView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedArmyServer) Cancel(context.Context, *ArmyId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedArmyServer) Flea(context.Context, *ArmyId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flea not implemented")
}
func (UnimplementedArmyServer) Flip(context.Context, *ArmyId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flip not implemented")
}
func (UnimplementedArmyServer) Move(context.Context, *ArmyMoveReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedArmyServer) Wait(context.Context, *ArmyTarget) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}
func (UnimplementedArmyServer) Attack(context.Context, *ArmyAssaultReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attack not implemented")
}
func (UnimplementedArmyServer) Defend(context.Context, *ArmyTarget) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Defend not implemented")
}
func (UnimplementedArmyServer) Disband(context.Context, *ArmyTarget) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disband not implemented")
}
func (UnimplementedArmyServer) mustEmbedUnimplementedArmyServer() {}

// UnsafeArmyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArmyServer will
// result in compilation errors.
type UnsafeArmyServer interface {
	mustEmbedUnimplementedArmyServer()
}

func RegisterArmyServer(s grpc.ServiceRegistrar, srv ArmyServer) {
	s.RegisterService(&Army_ServiceDesc, srv)
}

func _Army_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Show",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Show(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Cancel(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Flea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Flea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Flea",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Flea(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Flip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Flip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Flip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Flip(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyMoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Move(ctx, req.(*ArmyMoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Wait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Wait(ctx, req.(*ArmyTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Attack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyAssaultReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Attack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Attack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Attack(ctx, req.(*ArmyAssaultReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Defend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Defend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Defend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Defend(ctx, req.(*ArmyTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Disband_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Disband(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Disband",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Disband(ctx, req.(*ArmyTarget))
	}
	return interceptor(ctx, in, info, handler)
}

// Army_ServiceDesc is the grpc.ServiceDesc for Army service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Army_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Army",
	HandlerType: (*ArmyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Show",
			Handler:    _Army_Show_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _Army_Cancel_Handler,
		},
		{
			MethodName: "Flea",
			Handler:    _Army_Flea_Handler,
		},
		{
			MethodName: "Flip",
			Handler:    _Army_Flip_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _Army_Move_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _Army_Wait_Handler,
		},
		{
			MethodName: "Attack",
			Handler:    _Army_Attack_Handler,
		},
		{
			MethodName: "Defend",
			Handler:    _Army_Defend_Handler,
		},
		{
			MethodName: "Disband",
			Handler:    _Army_Disband_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "region.proto",
}
