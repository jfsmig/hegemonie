// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminClient interface {
	// Instantiate a region on the target server
	CreateRegion(ctx context.Context, in *RegionCreateReq, opts ...grpc.CallOption) (*Created, error)
	// PushStats extracts the usage in-game stats of each city in the given
	// region and pushes them to the collector.
	PushStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error)
}

type adminClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminClient(cc grpc.ClientConnInterface) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) CreateRegion(ctx context.Context, in *RegionCreateReq, opts ...grpc.CallOption) (*Created, error) {
	out := new(Created)
	err := c.cc.Invoke(ctx, "/hege.reg.Admin/CreateRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) PushStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Admin/PushStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
// All implementations must embed UnimplementedAdminServer
// for forward compatibility
type AdminServer interface {
	// Instantiate a region on the target server
	CreateRegion(context.Context, *RegionCreateReq) (*Created, error)
	// PushStats extracts the usage in-game stats of each city in the given
	// region and pushes them to the collector.
	PushStats(context.Context, *RegionId) (*None, error)
	mustEmbedUnimplementedAdminServer()
}

// UnimplementedAdminServer must be embedded to have forward compatible implementations.
type UnimplementedAdminServer struct {
}

func (UnimplementedAdminServer) CreateRegion(context.Context, *RegionCreateReq) (*Created, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRegion not implemented")
}
func (UnimplementedAdminServer) PushStats(context.Context, *RegionId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushStats not implemented")
}
func (UnimplementedAdminServer) mustEmbedUnimplementedAdminServer() {}

// UnsafeAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServer will
// result in compilation errors.
type UnsafeAdminServer interface {
	mustEmbedUnimplementedAdminServer()
}

func RegisterAdminServer(s grpc.ServiceRegistrar, srv AdminServer) {
	s.RegisterService(&Admin_ServiceDesc, srv)
}

func _Admin_CreateRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).CreateRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Admin/CreateRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).CreateRegion(ctx, req.(*RegionCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_PushStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).PushStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Admin/PushStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).PushStats(ctx, req.(*RegionId))
	}
	return interceptor(ctx, in, info, handler)
}

// Admin_ServiceDesc is the grpc.ServiceDesc for Admin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Admin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRegion",
			Handler:    _Admin_CreateRegion_Handler,
		},
		{
			MethodName: "PushStats",
			Handler:    _Admin_PushStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "region.proto",
}

// GameMasterClient is the client API for GameMaster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GameMasterClient interface {
	// Have all the Cities on the Region to produce their resources
	Produce(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error)
	// Make all the armies on the Region to move on step
	Move(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error)
	// Compute core statistics for the whole region.
	GetStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (GameMaster_GetStatsClient, error)
	GetDetail(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*CityView, error)
	LifecycleConfigure(ctx context.Context, in *LifecycleConfigureReq, opts ...grpc.CallOption) (*None, error)
	LifecycleAssign(ctx context.Context, in *LifecycleAssignReq, opts ...grpc.CallOption) (*None, error)
	LifecycleResume(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error)
	LifecycleDismiss(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error)
	LifecycleSuspend(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error)
	LifecycleReset(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error)
}

type gameMasterClient struct {
	cc grpc.ClientConnInterface
}

func NewGameMasterClient(cc grpc.ClientConnInterface) GameMasterClient {
	return &gameMasterClient{cc}
}

func (c *gameMasterClient) Produce(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/Produce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) Move(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/Move", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) GetStats(ctx context.Context, in *RegionId, opts ...grpc.CallOption) (GameMaster_GetStatsClient, error) {
	stream, err := c.cc.NewStream(ctx, &GameMaster_ServiceDesc.Streams[0], "/hege.reg.GameMaster/GetStats", opts...)
	if err != nil {
		return nil, err
	}
	x := &gameMasterGetStatsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GameMaster_GetStatsClient interface {
	Recv() (*CityStatsRecord, error)
	grpc.ClientStream
}

type gameMasterGetStatsClient struct {
	grpc.ClientStream
}

func (x *gameMasterGetStatsClient) Recv() (*CityStatsRecord, error) {
	m := new(CityStatsRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gameMasterClient) GetDetail(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*CityView, error) {
	out := new(CityView)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/GetDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) LifecycleConfigure(ctx context.Context, in *LifecycleConfigureReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/LifecycleConfigure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) LifecycleAssign(ctx context.Context, in *LifecycleAssignReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/LifecycleAssign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) LifecycleResume(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/LifecycleResume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) LifecycleDismiss(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/LifecycleDismiss", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) LifecycleSuspend(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/LifecycleSuspend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameMasterClient) LifecycleReset(ctx context.Context, in *LifecycleAbstractReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.GameMaster/LifecycleReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GameMasterServer is the server API for GameMaster service.
// All implementations must embed UnimplementedGameMasterServer
// for forward compatibility
type GameMasterServer interface {
	// Have all the Cities on the Region to produce their resources
	Produce(context.Context, *RegionId) (*None, error)
	// Make all the armies on the Region to move on step
	Move(context.Context, *RegionId) (*None, error)
	// Compute core statistics for the whole region.
	GetStats(*RegionId, GameMaster_GetStatsServer) error
	GetDetail(context.Context, *CityId) (*CityView, error)
	LifecycleConfigure(context.Context, *LifecycleConfigureReq) (*None, error)
	LifecycleAssign(context.Context, *LifecycleAssignReq) (*None, error)
	LifecycleResume(context.Context, *LifecycleAbstractReq) (*None, error)
	LifecycleDismiss(context.Context, *LifecycleAbstractReq) (*None, error)
	LifecycleSuspend(context.Context, *LifecycleAbstractReq) (*None, error)
	LifecycleReset(context.Context, *LifecycleAbstractReq) (*None, error)
	mustEmbedUnimplementedGameMasterServer()
}

// UnimplementedGameMasterServer must be embedded to have forward compatible implementations.
type UnimplementedGameMasterServer struct {
}

func (UnimplementedGameMasterServer) Produce(context.Context, *RegionId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Produce not implemented")
}
func (UnimplementedGameMasterServer) Move(context.Context, *RegionId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedGameMasterServer) GetStats(*RegionId, GameMaster_GetStatsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedGameMasterServer) GetDetail(context.Context, *CityId) (*CityView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDetail not implemented")
}
func (UnimplementedGameMasterServer) LifecycleConfigure(context.Context, *LifecycleConfigureReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleConfigure not implemented")
}
func (UnimplementedGameMasterServer) LifecycleAssign(context.Context, *LifecycleAssignReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleAssign not implemented")
}
func (UnimplementedGameMasterServer) LifecycleResume(context.Context, *LifecycleAbstractReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleResume not implemented")
}
func (UnimplementedGameMasterServer) LifecycleDismiss(context.Context, *LifecycleAbstractReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleDismiss not implemented")
}
func (UnimplementedGameMasterServer) LifecycleSuspend(context.Context, *LifecycleAbstractReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleSuspend not implemented")
}
func (UnimplementedGameMasterServer) LifecycleReset(context.Context, *LifecycleAbstractReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleReset not implemented")
}
func (UnimplementedGameMasterServer) mustEmbedUnimplementedGameMasterServer() {}

// UnsafeGameMasterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GameMasterServer will
// result in compilation errors.
type UnsafeGameMasterServer interface {
	mustEmbedUnimplementedGameMasterServer()
}

func RegisterGameMasterServer(s grpc.ServiceRegistrar, srv GameMasterServer) {
	s.RegisterService(&GameMaster_ServiceDesc, srv)
}

func _GameMaster_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).Produce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/Produce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).Produce(ctx, req.(*RegionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).Move(ctx, req.(*RegionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_GetStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegionId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GameMasterServer).GetStats(m, &gameMasterGetStatsServer{stream})
}

type GameMaster_GetStatsServer interface {
	Send(*CityStatsRecord) error
	grpc.ServerStream
}

type gameMasterGetStatsServer struct {
	grpc.ServerStream
}

func (x *gameMasterGetStatsServer) Send(m *CityStatsRecord) error {
	return x.ServerStream.SendMsg(m)
}

func _GameMaster_GetDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).GetDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/GetDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).GetDetail(ctx, req.(*CityId))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_LifecycleConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleConfigureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).LifecycleConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/LifecycleConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).LifecycleConfigure(ctx, req.(*LifecycleConfigureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_LifecycleAssign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleAssignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).LifecycleAssign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/LifecycleAssign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).LifecycleAssign(ctx, req.(*LifecycleAssignReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_LifecycleResume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleAbstractReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).LifecycleResume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/LifecycleResume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).LifecycleResume(ctx, req.(*LifecycleAbstractReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_LifecycleDismiss_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleAbstractReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).LifecycleDismiss(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/LifecycleDismiss",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).LifecycleDismiss(ctx, req.(*LifecycleAbstractReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_LifecycleSuspend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleAbstractReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).LifecycleSuspend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/LifecycleSuspend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).LifecycleSuspend(ctx, req.(*LifecycleAbstractReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameMaster_LifecycleReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleAbstractReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameMasterServer).LifecycleReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.GameMaster/LifecycleReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameMasterServer).LifecycleReset(ctx, req.(*LifecycleAbstractReq))
	}
	return interceptor(ctx, in, info, handler)
}

// GameMaster_ServiceDesc is the grpc.ServiceDesc for GameMaster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GameMaster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.GameMaster",
	HandlerType: (*GameMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Produce",
			Handler:    _GameMaster_Produce_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _GameMaster_Move_Handler,
		},
		{
			MethodName: "GetDetail",
			Handler:    _GameMaster_GetDetail_Handler,
		},
		{
			MethodName: "LifecycleConfigure",
			Handler:    _GameMaster_LifecycleConfigure_Handler,
		},
		{
			MethodName: "LifecycleAssign",
			Handler:    _GameMaster_LifecycleAssign_Handler,
		},
		{
			MethodName: "LifecycleResume",
			Handler:    _GameMaster_LifecycleResume_Handler,
		},
		{
			MethodName: "LifecycleDismiss",
			Handler:    _GameMaster_LifecycleDismiss_Handler,
		},
		{
			MethodName: "LifecycleSuspend",
			Handler:    _GameMaster_LifecycleSuspend_Handler,
		},
		{
			MethodName: "LifecycleReset",
			Handler:    _GameMaster_LifecycleReset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetStats",
			Handler:       _GameMaster_GetStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// PublicClient is the client API for Public service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicClient interface {
	ListRegions(ctx context.Context, in *RegionListReq, opts ...grpc.CallOption) (Public_ListRegionsClient, error)
	// Paginated query of all the cities of the region.
	// Only a summary of the cities are returned.
	AllCities(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Public_AllCitiesClient, error)
}

type publicClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicClient(cc grpc.ClientConnInterface) PublicClient {
	return &publicClient{cc}
}

func (c *publicClient) ListRegions(ctx context.Context, in *RegionListReq, opts ...grpc.CallOption) (Public_ListRegionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Public_ServiceDesc.Streams[0], "/hege.reg.Public/ListRegions", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicListRegionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Public_ListRegionsClient interface {
	Recv() (*RegionSummary, error)
	grpc.ClientStream
}

type publicListRegionsClient struct {
	grpc.ClientStream
}

func (x *publicListRegionsClient) Recv() (*RegionSummary, error) {
	m := new(RegionSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *publicClient) AllCities(ctx context.Context, in *PaginatedU64Query, opts ...grpc.CallOption) (Public_AllCitiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Public_ServiceDesc.Streams[1], "/hege.reg.Public/AllCities", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicAllCitiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Public_AllCitiesClient interface {
	Recv() (*CityKey, error)
	grpc.ClientStream
}

type publicAllCitiesClient struct {
	grpc.ClientStream
}

func (x *publicAllCitiesClient) Recv() (*CityKey, error) {
	m := new(CityKey)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PublicServer is the server API for Public service.
// All implementations must embed UnimplementedPublicServer
// for forward compatibility
type PublicServer interface {
	ListRegions(*RegionListReq, Public_ListRegionsServer) error
	// Paginated query of all the cities of the region.
	// Only a summary of the cities are returned.
	AllCities(*PaginatedU64Query, Public_AllCitiesServer) error
	mustEmbedUnimplementedPublicServer()
}

// UnimplementedPublicServer must be embedded to have forward compatible implementations.
type UnimplementedPublicServer struct {
}

func (UnimplementedPublicServer) ListRegions(*RegionListReq, Public_ListRegionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListRegions not implemented")
}
func (UnimplementedPublicServer) AllCities(*PaginatedU64Query, Public_AllCitiesServer) error {
	return status.Errorf(codes.Unimplemented, "method AllCities not implemented")
}
func (UnimplementedPublicServer) mustEmbedUnimplementedPublicServer() {}

// UnsafePublicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicServer will
// result in compilation errors.
type UnsafePublicServer interface {
	mustEmbedUnimplementedPublicServer()
}

func RegisterPublicServer(s grpc.ServiceRegistrar, srv PublicServer) {
	s.RegisterService(&Public_ServiceDesc, srv)
}

func _Public_ListRegions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegionListReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PublicServer).ListRegions(m, &publicListRegionsServer{stream})
}

type Public_ListRegionsServer interface {
	Send(*RegionSummary) error
	grpc.ServerStream
}

type publicListRegionsServer struct {
	grpc.ServerStream
}

func (x *publicListRegionsServer) Send(m *RegionSummary) error {
	return x.ServerStream.SendMsg(m)
}

func _Public_AllCities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedU64Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PublicServer).AllCities(m, &publicAllCitiesServer{stream})
}

type Public_AllCitiesServer interface {
	Send(*CityKey) error
	grpc.ServerStream
}

type publicAllCitiesServer struct {
	grpc.ServerStream
}

func (x *publicAllCitiesServer) Send(m *CityKey) error {
	return x.ServerStream.SendMsg(m)
}

// Public_ServiceDesc is the grpc.ServiceDesc for Public service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Public_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Public",
	HandlerType: (*PublicServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListRegions",
			Handler:       _Public_ListRegions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AllCities",
			Handler:       _Public_AllCities_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// TemplatesClient is the client API for Templates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TemplatesClient interface {
	ListTemplates(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Templates_ListTemplatesClient, error)
	CreateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*Created, error)
	UpdateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*None, error)
	DeleteTemplate(ctx context.Context, in *TemplateId, opts ...grpc.CallOption) (*None, error)
}

type templatesClient struct {
	cc grpc.ClientConnInterface
}

func NewTemplatesClient(cc grpc.ClientConnInterface) TemplatesClient {
	return &templatesClient{cc}
}

func (c *templatesClient) ListTemplates(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Templates_ListTemplatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Templates_ServiceDesc.Streams[0], "/hege.reg.Templates/ListTemplates", opts...)
	if err != nil {
		return nil, err
	}
	x := &templatesListTemplatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Templates_ListTemplatesClient interface {
	Recv() (*CityTemplate, error)
	grpc.ClientStream
}

type templatesListTemplatesClient struct {
	grpc.ClientStream
}

func (x *templatesListTemplatesClient) Recv() (*CityTemplate, error) {
	m := new(CityTemplate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *templatesClient) CreateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*Created, error) {
	out := new(Created)
	err := c.cc.Invoke(ctx, "/hege.reg.Templates/CreateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) UpdateTemplate(ctx context.Context, in *CityTemplateReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Templates/UpdateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templatesClient) DeleteTemplate(ctx context.Context, in *TemplateId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Templates/DeleteTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TemplatesServer is the server API for Templates service.
// All implementations must embed UnimplementedTemplatesServer
// for forward compatibility
type TemplatesServer interface {
	ListTemplates(*PaginatedStrQuery, Templates_ListTemplatesServer) error
	CreateTemplate(context.Context, *CityTemplateReq) (*Created, error)
	UpdateTemplate(context.Context, *CityTemplateReq) (*None, error)
	DeleteTemplate(context.Context, *TemplateId) (*None, error)
	mustEmbedUnimplementedTemplatesServer()
}

// UnimplementedTemplatesServer must be embedded to have forward compatible implementations.
type UnimplementedTemplatesServer struct {
}

func (UnimplementedTemplatesServer) ListTemplates(*PaginatedStrQuery, Templates_ListTemplatesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTemplates not implemented")
}
func (UnimplementedTemplatesServer) CreateTemplate(context.Context, *CityTemplateReq) (*Created, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTemplate not implemented")
}
func (UnimplementedTemplatesServer) UpdateTemplate(context.Context, *CityTemplateReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTemplate not implemented")
}
func (UnimplementedTemplatesServer) DeleteTemplate(context.Context, *TemplateId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTemplate not implemented")
}
func (UnimplementedTemplatesServer) mustEmbedUnimplementedTemplatesServer() {}

// UnsafeTemplatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TemplatesServer will
// result in compilation errors.
type UnsafeTemplatesServer interface {
	mustEmbedUnimplementedTemplatesServer()
}

func RegisterTemplatesServer(s grpc.ServiceRegistrar, srv TemplatesServer) {
	s.RegisterService(&Templates_ServiceDesc, srv)
}

func _Templates_ListTemplates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedStrQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TemplatesServer).ListTemplates(m, &templatesListTemplatesServer{stream})
}

type Templates_ListTemplatesServer interface {
	Send(*CityTemplate) error
	grpc.ServerStream
}

type templatesListTemplatesServer struct {
	grpc.ServerStream
}

func (x *templatesListTemplatesServer) Send(m *CityTemplate) error {
	return x.ServerStream.SendMsg(m)
}

func _Templates_CreateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityTemplateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).CreateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Templates/CreateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).CreateTemplate(ctx, req.(*CityTemplateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_UpdateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityTemplateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).UpdateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Templates/UpdateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).UpdateTemplate(ctx, req.(*CityTemplateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Templates_DeleteTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TemplateId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplatesServer).DeleteTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Templates/DeleteTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplatesServer).DeleteTemplate(ctx, req.(*TemplateId))
	}
	return interceptor(ctx, in, info, handler)
}

// Templates_ServiceDesc is the grpc.ServiceDesc for Templates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Templates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Templates",
	HandlerType: (*TemplatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTemplate",
			Handler:    _Templates_CreateTemplate_Handler,
		},
		{
			MethodName: "UpdateTemplate",
			Handler:    _Templates_UpdateTemplate_Handler,
		},
		{
			MethodName: "DeleteTemplate",
			Handler:    _Templates_DeleteTemplate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListTemplates",
			Handler:       _Templates_ListTemplates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// DefinitionsClient is the client API for Definitions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DefinitionsClient interface {
	// Return (a page of) a list of all the Units that are possible in the world
	ListUnits(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Definitions_ListUnitsClient, error)
	// Return (a page of) a list of all the Buildings that are possible in the world
	ListBuildings(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Definitions_ListBuildingsClient, error)
	// Return (a page of) a list of all the Skill that are possible in the world
	ListSkills(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Definitions_ListSkillsClient, error)
}

type definitionsClient struct {
	cc grpc.ClientConnInterface
}

func NewDefinitionsClient(cc grpc.ClientConnInterface) DefinitionsClient {
	return &definitionsClient{cc}
}

func (c *definitionsClient) ListUnits(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Definitions_ListUnitsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Definitions_ServiceDesc.Streams[0], "/hege.reg.Definitions/ListUnits", opts...)
	if err != nil {
		return nil, err
	}
	x := &definitionsListUnitsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Definitions_ListUnitsClient interface {
	Recv() (*UnitTypeView, error)
	grpc.ClientStream
}

type definitionsListUnitsClient struct {
	grpc.ClientStream
}

func (x *definitionsListUnitsClient) Recv() (*UnitTypeView, error) {
	m := new(UnitTypeView)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *definitionsClient) ListBuildings(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Definitions_ListBuildingsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Definitions_ServiceDesc.Streams[1], "/hege.reg.Definitions/ListBuildings", opts...)
	if err != nil {
		return nil, err
	}
	x := &definitionsListBuildingsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Definitions_ListBuildingsClient interface {
	Recv() (*BuildingTypeView, error)
	grpc.ClientStream
}

type definitionsListBuildingsClient struct {
	grpc.ClientStream
}

func (x *definitionsListBuildingsClient) Recv() (*BuildingTypeView, error) {
	m := new(BuildingTypeView)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *definitionsClient) ListSkills(ctx context.Context, in *PaginatedStrQuery, opts ...grpc.CallOption) (Definitions_ListSkillsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Definitions_ServiceDesc.Streams[2], "/hege.reg.Definitions/ListSkills", opts...)
	if err != nil {
		return nil, err
	}
	x := &definitionsListSkillsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Definitions_ListSkillsClient interface {
	Recv() (*SkillTypeView, error)
	grpc.ClientStream
}

type definitionsListSkillsClient struct {
	grpc.ClientStream
}

func (x *definitionsListSkillsClient) Recv() (*SkillTypeView, error) {
	m := new(SkillTypeView)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DefinitionsServer is the server API for Definitions service.
// All implementations must embed UnimplementedDefinitionsServer
// for forward compatibility
type DefinitionsServer interface {
	// Return (a page of) a list of all the Units that are possible in the world
	ListUnits(*PaginatedStrQuery, Definitions_ListUnitsServer) error
	// Return (a page of) a list of all the Buildings that are possible in the world
	ListBuildings(*PaginatedStrQuery, Definitions_ListBuildingsServer) error
	// Return (a page of) a list of all the Skill that are possible in the world
	ListSkills(*PaginatedStrQuery, Definitions_ListSkillsServer) error
	mustEmbedUnimplementedDefinitionsServer()
}

// UnimplementedDefinitionsServer must be embedded to have forward compatible implementations.
type UnimplementedDefinitionsServer struct {
}

func (UnimplementedDefinitionsServer) ListUnits(*PaginatedStrQuery, Definitions_ListUnitsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListUnits not implemented")
}
func (UnimplementedDefinitionsServer) ListBuildings(*PaginatedStrQuery, Definitions_ListBuildingsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListBuildings not implemented")
}
func (UnimplementedDefinitionsServer) ListSkills(*PaginatedStrQuery, Definitions_ListSkillsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListSkills not implemented")
}
func (UnimplementedDefinitionsServer) mustEmbedUnimplementedDefinitionsServer() {}

// UnsafeDefinitionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DefinitionsServer will
// result in compilation errors.
type UnsafeDefinitionsServer interface {
	mustEmbedUnimplementedDefinitionsServer()
}

func RegisterDefinitionsServer(s grpc.ServiceRegistrar, srv DefinitionsServer) {
	s.RegisterService(&Definitions_ServiceDesc, srv)
}

func _Definitions_ListUnits_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedStrQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DefinitionsServer).ListUnits(m, &definitionsListUnitsServer{stream})
}

type Definitions_ListUnitsServer interface {
	Send(*UnitTypeView) error
	grpc.ServerStream
}

type definitionsListUnitsServer struct {
	grpc.ServerStream
}

func (x *definitionsListUnitsServer) Send(m *UnitTypeView) error {
	return x.ServerStream.SendMsg(m)
}

func _Definitions_ListBuildings_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedStrQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DefinitionsServer).ListBuildings(m, &definitionsListBuildingsServer{stream})
}

type Definitions_ListBuildingsServer interface {
	Send(*BuildingTypeView) error
	grpc.ServerStream
}

type definitionsListBuildingsServer struct {
	grpc.ServerStream
}

func (x *definitionsListBuildingsServer) Send(m *BuildingTypeView) error {
	return x.ServerStream.SendMsg(m)
}

func _Definitions_ListSkills_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PaginatedStrQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DefinitionsServer).ListSkills(m, &definitionsListSkillsServer{stream})
}

type Definitions_ListSkillsServer interface {
	Send(*SkillTypeView) error
	grpc.ServerStream
}

type definitionsListSkillsServer struct {
	grpc.ServerStream
}

func (x *definitionsListSkillsServer) Send(m *SkillTypeView) error {
	return x.ServerStream.SendMsg(m)
}

// Definitions_ServiceDesc is the grpc.ServiceDesc for Definitions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Definitions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Definitions",
	HandlerType: (*DefinitionsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListUnits",
			Handler:       _Definitions_ListUnits_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListBuildings",
			Handler:       _Definitions_ListBuildings_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListSkills",
			Handler:       _Definitions_ListSkills_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// PlayerClient is the client API for Player service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlayerClient interface {
	LifecycleConfigure(ctx context.Context, in *LifecycleConfigureReq, opts ...grpc.CallOption) (*None, error)
	LifecycleAcquire(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*None, error)
	LifecycleLeave(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*None, error)
	LifecycleAuto(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*None, error)
}

type playerClient struct {
	cc grpc.ClientConnInterface
}

func NewPlayerClient(cc grpc.ClientConnInterface) PlayerClient {
	return &playerClient{cc}
}

func (c *playerClient) LifecycleConfigure(ctx context.Context, in *LifecycleConfigureReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Player/LifecycleConfigure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) LifecycleAcquire(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Player/LifecycleAcquire", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) LifecycleLeave(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Player/LifecycleLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) LifecycleAuto(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Player/LifecycleAuto", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlayerServer is the server API for Player service.
// All implementations must embed UnimplementedPlayerServer
// for forward compatibility
type PlayerServer interface {
	LifecycleConfigure(context.Context, *LifecycleConfigureReq) (*None, error)
	LifecycleAcquire(context.Context, *CityId) (*None, error)
	LifecycleLeave(context.Context, *CityId) (*None, error)
	LifecycleAuto(context.Context, *CityId) (*None, error)
	mustEmbedUnimplementedPlayerServer()
}

// UnimplementedPlayerServer must be embedded to have forward compatible implementations.
type UnimplementedPlayerServer struct {
}

func (UnimplementedPlayerServer) LifecycleConfigure(context.Context, *LifecycleConfigureReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleConfigure not implemented")
}
func (UnimplementedPlayerServer) LifecycleAcquire(context.Context, *CityId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleAcquire not implemented")
}
func (UnimplementedPlayerServer) LifecycleLeave(context.Context, *CityId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleLeave not implemented")
}
func (UnimplementedPlayerServer) LifecycleAuto(context.Context, *CityId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LifecycleAuto not implemented")
}
func (UnimplementedPlayerServer) mustEmbedUnimplementedPlayerServer() {}

// UnsafePlayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlayerServer will
// result in compilation errors.
type UnsafePlayerServer interface {
	mustEmbedUnimplementedPlayerServer()
}

func RegisterPlayerServer(s grpc.ServiceRegistrar, srv PlayerServer) {
	s.RegisterService(&Player_ServiceDesc, srv)
}

func _Player_LifecycleConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleConfigureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).LifecycleConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Player/LifecycleConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).LifecycleConfigure(ctx, req.(*LifecycleConfigureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_LifecycleAcquire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).LifecycleAcquire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Player/LifecycleAcquire",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).LifecycleAcquire(ctx, req.(*CityId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_LifecycleLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).LifecycleLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Player/LifecycleLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).LifecycleLeave(ctx, req.(*CityId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_LifecycleAuto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).LifecycleAuto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Player/LifecycleAuto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).LifecycleAuto(ctx, req.(*CityId))
	}
	return interceptor(ctx, in, info, handler)
}

// Player_ServiceDesc is the grpc.ServiceDesc for Player service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Player_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Player",
	HandlerType: (*PlayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LifecycleConfigure",
			Handler:    _Player_LifecycleConfigure_Handler,
		},
		{
			MethodName: "LifecycleAcquire",
			Handler:    _Player_LifecycleAcquire_Handler,
		},
		{
			MethodName: "LifecycleLeave",
			Handler:    _Player_LifecycleLeave_Handler,
		},
		{
			MethodName: "LifecycleAuto",
			Handler:    _Player_LifecycleAuto_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "region.proto",
}

// CityClient is the client API for City service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CityClient interface {
	// Paginated query of the cities owned by the given user.
	// Only a summary of the cities are returned.
	List(ctx context.Context, in *CitiesByOwnerReq, opts ...grpc.CallOption) (City_ListClient, error)
	// Returns a complete view of the City
	// TODO(jfs): the request might fail because of a too large object
	//            to be replied.
	ShowAll(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*CityView, error)
	// Start the study of a skill whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Study(ctx context.Context, in *StudyReq, opts ...grpc.CallOption) (*None, error)
	// Start the construction of a building whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Build(ctx context.Context, in *BuildReq, opts ...grpc.CallOption) (*None, error)
	// Start the training of a Unit whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Train(ctx context.Context, in *TrainReq, opts ...grpc.CallOption) (*None, error)
	// Create an army around a set of units.
	// The set of units must not be empty and all the units must stay in the given City.
	CreateArmy(ctx context.Context, in *CreateArmyReq, opts ...grpc.CallOption) (*None, error)
	// Create an army around a pile of resources, with a given destination.
	// The army immediately preempts the stock in the reserve of the City
	// and starts it movement. That army will have no aggressivity.
	CreateTransport(ctx context.Context, in *CreateTransportReq, opts ...grpc.CallOption) (*None, error)
	// Transfer a Unit from the given City to the given Army.
	// The City must control the Army and the Unit must be in the City.
	TransferUnit(ctx context.Context, in *TransferUnitReq, opts ...grpc.CallOption) (*None, error)
	// Transfer a pile of Resources from the given City to the given Army.
	// The City must control the Army and the Stock must hold the amount of Resources.
	TransferResources(ctx context.Context, in *TransferResourcesReq, opts ...grpc.CallOption) (*None, error)
	// Return the list of armies that can be controlled by the given City
	ListArmies(ctx context.Context, in *CityId, opts ...grpc.CallOption) (City_ListArmiesClient, error)
}

type cityClient struct {
	cc grpc.ClientConnInterface
}

func NewCityClient(cc grpc.ClientConnInterface) CityClient {
	return &cityClient{cc}
}

func (c *cityClient) List(ctx context.Context, in *CitiesByOwnerReq, opts ...grpc.CallOption) (City_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &City_ServiceDesc.Streams[0], "/hege.reg.City/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type City_ListClient interface {
	Recv() (*CityKey, error)
	grpc.ClientStream
}

type cityListClient struct {
	grpc.ClientStream
}

func (x *cityListClient) Recv() (*CityKey, error) {
	m := new(CityKey)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cityClient) ShowAll(ctx context.Context, in *CityId, opts ...grpc.CallOption) (*CityView, error) {
	out := new(CityView)
	err := c.cc.Invoke(ctx, "/hege.reg.City/ShowAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) Study(ctx context.Context, in *StudyReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/Study", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) Build(ctx context.Context, in *BuildReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/Build", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) Train(ctx context.Context, in *TrainReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/Train", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) CreateArmy(ctx context.Context, in *CreateArmyReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/CreateArmy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) CreateTransport(ctx context.Context, in *CreateTransportReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/CreateTransport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) TransferUnit(ctx context.Context, in *TransferUnitReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/TransferUnit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) TransferResources(ctx context.Context, in *TransferResourcesReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.City/TransferResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityClient) ListArmies(ctx context.Context, in *CityId, opts ...grpc.CallOption) (City_ListArmiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &City_ServiceDesc.Streams[1], "/hege.reg.City/ListArmies", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityListArmiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type City_ListArmiesClient interface {
	Recv() (*ArmyName, error)
	grpc.ClientStream
}

type cityListArmiesClient struct {
	grpc.ClientStream
}

func (x *cityListArmiesClient) Recv() (*ArmyName, error) {
	m := new(ArmyName)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CityServer is the server API for City service.
// All implementations must embed UnimplementedCityServer
// for forward compatibility
type CityServer interface {
	// Paginated query of the cities owned by the given user.
	// Only a summary of the cities are returned.
	List(*CitiesByOwnerReq, City_ListServer) error
	// Returns a complete view of the City
	// TODO(jfs): the request might fail because of a too large object
	//            to be replied.
	ShowAll(context.Context, *CityId) (*CityView, error)
	// Start the study of a skill whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Study(context.Context, *StudyReq) (*None, error)
	// Start the construction of a building whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Build(context.Context, *BuildReq) (*None, error)
	// Start the training of a Unit whose type is specified by its unique ID.
	// If the conditions are not met, an error is returned.
	Train(context.Context, *TrainReq) (*None, error)
	// Create an army around a set of units.
	// The set of units must not be empty and all the units must stay in the given City.
	CreateArmy(context.Context, *CreateArmyReq) (*None, error)
	// Create an army around a pile of resources, with a given destination.
	// The army immediately preempts the stock in the reserve of the City
	// and starts it movement. That army will have no aggressivity.
	CreateTransport(context.Context, *CreateTransportReq) (*None, error)
	// Transfer a Unit from the given City to the given Army.
	// The City must control the Army and the Unit must be in the City.
	TransferUnit(context.Context, *TransferUnitReq) (*None, error)
	// Transfer a pile of Resources from the given City to the given Army.
	// The City must control the Army and the Stock must hold the amount of Resources.
	TransferResources(context.Context, *TransferResourcesReq) (*None, error)
	// Return the list of armies that can be controlled by the given City
	ListArmies(*CityId, City_ListArmiesServer) error
	mustEmbedUnimplementedCityServer()
}

// UnimplementedCityServer must be embedded to have forward compatible implementations.
type UnimplementedCityServer struct {
}

func (UnimplementedCityServer) List(*CitiesByOwnerReq, City_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCityServer) ShowAll(context.Context, *CityId) (*CityView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowAll not implemented")
}
func (UnimplementedCityServer) Study(context.Context, *StudyReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Study not implemented")
}
func (UnimplementedCityServer) Build(context.Context, *BuildReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedCityServer) Train(context.Context, *TrainReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Train not implemented")
}
func (UnimplementedCityServer) CreateArmy(context.Context, *CreateArmyReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArmy not implemented")
}
func (UnimplementedCityServer) CreateTransport(context.Context, *CreateTransportReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTransport not implemented")
}
func (UnimplementedCityServer) TransferUnit(context.Context, *TransferUnitReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferUnit not implemented")
}
func (UnimplementedCityServer) TransferResources(context.Context, *TransferResourcesReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferResources not implemented")
}
func (UnimplementedCityServer) ListArmies(*CityId, City_ListArmiesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListArmies not implemented")
}
func (UnimplementedCityServer) mustEmbedUnimplementedCityServer() {}

// UnsafeCityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CityServer will
// result in compilation errors.
type UnsafeCityServer interface {
	mustEmbedUnimplementedCityServer()
}

func RegisterCityServer(s grpc.ServiceRegistrar, srv CityServer) {
	s.RegisterService(&City_ServiceDesc, srv)
}

func _City_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CitiesByOwnerReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServer).List(m, &cityListServer{stream})
}

type City_ListServer interface {
	Send(*CityKey) error
	grpc.ServerStream
}

type cityListServer struct {
	grpc.ServerStream
}

func (x *cityListServer) Send(m *CityKey) error {
	return x.ServerStream.SendMsg(m)
}

func _City_ShowAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).ShowAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/ShowAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).ShowAll(ctx, req.(*CityId))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_Study_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).Study(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/Study",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).Study(ctx, req.(*StudyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/Build",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).Build(ctx, req.(*BuildReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_Train_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrainReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).Train(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/Train",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).Train(ctx, req.(*TrainReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_CreateArmy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateArmyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).CreateArmy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/CreateArmy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).CreateArmy(ctx, req.(*CreateArmyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_CreateTransport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTransportReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).CreateTransport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/CreateTransport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).CreateTransport(ctx, req.(*CreateTransportReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_TransferUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferUnitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).TransferUnit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/TransferUnit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).TransferUnit(ctx, req.(*TransferUnitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_TransferResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferResourcesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServer).TransferResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.City/TransferResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServer).TransferResources(ctx, req.(*TransferResourcesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _City_ListArmies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CityId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServer).ListArmies(m, &cityListArmiesServer{stream})
}

type City_ListArmiesServer interface {
	Send(*ArmyName) error
	grpc.ServerStream
}

type cityListArmiesServer struct {
	grpc.ServerStream
}

func (x *cityListArmiesServer) Send(m *ArmyName) error {
	return x.ServerStream.SendMsg(m)
}

// City_ServiceDesc is the grpc.ServiceDesc for City service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var City_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.City",
	HandlerType: (*CityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShowAll",
			Handler:    _City_ShowAll_Handler,
		},
		{
			MethodName: "Study",
			Handler:    _City_Study_Handler,
		},
		{
			MethodName: "Build",
			Handler:    _City_Build_Handler,
		},
		{
			MethodName: "Train",
			Handler:    _City_Train_Handler,
		},
		{
			MethodName: "CreateArmy",
			Handler:    _City_CreateArmy_Handler,
		},
		{
			MethodName: "CreateTransport",
			Handler:    _City_CreateTransport_Handler,
		},
		{
			MethodName: "TransferUnit",
			Handler:    _City_TransferUnit_Handler,
		},
		{
			MethodName: "TransferResources",
			Handler:    _City_TransferResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _City_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListArmies",
			Handler:       _City_ListArmies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "region.proto",
}

// ArmyClient is the client API for Army service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ArmyClient interface {
	// Return a detailed view of the given Army
	Show(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*ArmyView, error)
	// Destroy the army and return all its content to the local city
	// Only works when the city is at home.
	Cancel(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error)
	// Make the Army flea the fight it is involved in.
	Flea(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error)
	// Make the Army flip in the fight it is involved in.
	Flip(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Move(ctx context.Context, in *ArmyMoveReq, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Wait(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Attack(ctx context.Context, in *ArmyAssaultReq, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Defend(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error)
	// Append the specified command on the list of the Army.
	Disband(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error)
}

type armyClient struct {
	cc grpc.ClientConnInterface
}

func NewArmyClient(cc grpc.ClientConnInterface) ArmyClient {
	return &armyClient{cc}
}

func (c *armyClient) Show(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*ArmyView, error) {
	out := new(ArmyView)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Show", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Cancel(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Flea(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Flea", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Flip(ctx context.Context, in *ArmyId, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Flip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Move(ctx context.Context, in *ArmyMoveReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Move", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Wait(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Wait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Attack(ctx context.Context, in *ArmyAssaultReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Attack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Defend(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Defend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *armyClient) Disband(ctx context.Context, in *ArmyTarget, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := c.cc.Invoke(ctx, "/hege.reg.Army/Disband", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArmyServer is the server API for Army service.
// All implementations must embed UnimplementedArmyServer
// for forward compatibility
type ArmyServer interface {
	// Return a detailed view of the given Army
	Show(context.Context, *ArmyId) (*ArmyView, error)
	// Destroy the army and return all its content to the local city
	// Only works when the city is at home.
	Cancel(context.Context, *ArmyId) (*None, error)
	// Make the Army flea the fight it is involved in.
	Flea(context.Context, *ArmyId) (*None, error)
	// Make the Army flip in the fight it is involved in.
	Flip(context.Context, *ArmyId) (*None, error)
	// Append the specified command on the list of the Army.
	Move(context.Context, *ArmyMoveReq) (*None, error)
	// Append the specified command on the list of the Army.
	Wait(context.Context, *ArmyTarget) (*None, error)
	// Append the specified command on the list of the Army.
	Attack(context.Context, *ArmyAssaultReq) (*None, error)
	// Append the specified command on the list of the Army.
	Defend(context.Context, *ArmyTarget) (*None, error)
	// Append the specified command on the list of the Army.
	Disband(context.Context, *ArmyTarget) (*None, error)
	mustEmbedUnimplementedArmyServer()
}

// UnimplementedArmyServer must be embedded to have forward compatible implementations.
type UnimplementedArmyServer struct {
}

func (UnimplementedArmyServer) Show(context.Context, *ArmyId) (*ArmyView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Show not implemented")
}
func (UnimplementedArmyServer) Cancel(context.Context, *ArmyId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedArmyServer) Flea(context.Context, *ArmyId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flea not implemented")
}
func (UnimplementedArmyServer) Flip(context.Context, *ArmyId) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flip not implemented")
}
func (UnimplementedArmyServer) Move(context.Context, *ArmyMoveReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedArmyServer) Wait(context.Context, *ArmyTarget) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}
func (UnimplementedArmyServer) Attack(context.Context, *ArmyAssaultReq) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attack not implemented")
}
func (UnimplementedArmyServer) Defend(context.Context, *ArmyTarget) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Defend not implemented")
}
func (UnimplementedArmyServer) Disband(context.Context, *ArmyTarget) (*None, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disband not implemented")
}
func (UnimplementedArmyServer) mustEmbedUnimplementedArmyServer() {}

// UnsafeArmyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArmyServer will
// result in compilation errors.
type UnsafeArmyServer interface {
	mustEmbedUnimplementedArmyServer()
}

func RegisterArmyServer(s grpc.ServiceRegistrar, srv ArmyServer) {
	s.RegisterService(&Army_ServiceDesc, srv)
}

func _Army_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Show",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Show(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Cancel(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Flea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Flea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Flea",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Flea(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Flip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Flip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Flip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Flip(ctx, req.(*ArmyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyMoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Move(ctx, req.(*ArmyMoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Wait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Wait(ctx, req.(*ArmyTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Attack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyAssaultReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Attack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Attack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Attack(ctx, req.(*ArmyAssaultReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Defend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Defend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Defend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Defend(ctx, req.(*ArmyTarget))
	}
	return interceptor(ctx, in, info, handler)
}

func _Army_Disband_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArmyTarget)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArmyServer).Disband(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hege.reg.Army/Disband",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArmyServer).Disband(ctx, req.(*ArmyTarget))
	}
	return interceptor(ctx, in, info, handler)
}

// Army_ServiceDesc is the grpc.ServiceDesc for Army service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Army_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hege.reg.Army",
	HandlerType: (*ArmyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Show",
			Handler:    _Army_Show_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _Army_Cancel_Handler,
		},
		{
			MethodName: "Flea",
			Handler:    _Army_Flea_Handler,
		},
		{
			MethodName: "Flip",
			Handler:    _Army_Flip_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _Army_Move_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _Army_Wait_Handler,
		},
		{
			MethodName: "Attack",
			Handler:    _Army_Attack_Handler,
		},
		{
			MethodName: "Defend",
			Handler:    _Army_Defend_Handler,
		},
		{
			MethodName: "Disband",
			Handler:    _Army_Disband_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "region.proto",
}
